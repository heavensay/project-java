<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Insert title here</title>
	<script type="text/javascript">
		console.log('*************test typeof*****************');
		//typeof 运算符把类型信息当作字符串返回。typeof 返回值有六种可能："number"、"string"、"boolean"、"object"、"function" 和 "undefined"。
		console.log('typeof new Date:'+typeof new Date    //"object"
			+'\ntypeof 1:'+typeof 1					//"number"
			+'\ntypeof undefined:'+typeof undefined  //"undefined"
			+'\ntypeof NaN:'+typeof NaN             //"number"
			+'\n*****typeof null:'+typeof null);   //"object" 
		
		//NaN
		console.log('*************test NaN*****************');
		console.log('Number.NaN===Number.NaN:'+(Number.NaN===Number.NaN));  //false
		console.log('isNaN(NaN):'+isNaN(NaN));     //true
		console.log("isNaN('abc'):"+isNaN('abc'));   //true
		console.log('isNaN(123):'+isNaN(123));    //false
		
		 
	/****
		作用域链：
	***/
		console.log('*************test scope 作用域链******************');
		var scope='global scope';
		function testScope(){
			var scope='local scope';
			this.g_scope = ' it is global scope ';
			var innerScopeFunction = function(){
				console.log(scope);    
			}
			return  innerScopeFunction;
		}		
	    testScope()();    // local scope
	    console.log(g_scope);  //it is global scope
		   /***************** this关键字 ********************/
		   console.log('*************test static*****************');
		   function testStatic(){
		   		this.nickname='tom';
		   }
		   //定义对象静态变量
		   testStatic.st = 'static var';
		   
		   var ts = new testStatic();
		   console.log(testStatic.st); //static var
		   console.log(ts.st);         //undefined
			
		   /***************** prototype ********************/
		   console.log('*************test prototype*****************');
		   
		   function prt(){
		   		this.f1 = function(){
		   			console.log('f1');
		   		}
		   }
		   prt.f2 = function(){
		   	  console.log('f2');
		   }
		   
		   prt.prototype.f3=function(){
		  	  console.log('f3');
		   }	 
		   
		   var prt1 = new prt();
		   prt1.f1();   	//f1
		   // prt1.f2();	//syntax error 
		   prt.f2();   		//f2
		   // prt.f1(); 	//syntax error
		   
		   //prt.f3();   	//syntax error
		   prt1.f3(); 		//f3
			
			var ar = [];
	  		console.log(ar.prototype===Array);
	  		console.log(prt.prototype);
	  		console.log(prt1.prototype);


    /*********
Function

　　首先回顾一下函数对象的概念，函数就是对象,代表函数的对象就是函数对象。所有的函数对象是被Function这个函数对象构造出来的。也就是说，Function是最顶层的构造器。它构造了系统中所有的对象，包括用户自定义对象，系统内置对象，甚至包括它自已。这也表明Function具有自举性(自已构造自己的能力)。这也间接决定了Function的[[call]]和[[constructor]]逻辑相同。

o为对象，是普通对象；f为函数，其实函数也是对象，函数对象，既然是函数也是对象，所以必然含有对象拥有的全部性质，包括对象在创建时设定的原型链__proto__属性。

Object　

　　对于Object它是最顶层的对象，所有的对象都将继承Object的原型，但是你也要明确的知道Object也是一个函数对象，所以说Object是被Function构造出来的。



 prototype指对象显示的prototype属性，而[[Prototype]]则代表对象内部Prototype属性(隐式的)。构成对象Prototype链的是内部隐式的[[Prototype]]，而并非对象显示的prototype属性。显示的prototype只有在函数对象上才有意义，从上面的创建过程可以看到，函数的prototype被赋给派生对象隐式[[Prototype]]属性，这样根据Prototype规则，派生对象和函数的prototype对象之间才存在属性、方法的继承/共享关系



		1 函数对象有一个显示的prototype原型对象(普通对象(i.e.  {} )是没有prototype属性的)
		2 js中每定义或实例化一个对象的时候，都附加一个名为__proto__的隐藏属性(firefox跟chrome中名称为__proto__，并且可以被访问到)，
		原型链正是基于__proto__才得以形成
	***********/

	
	console.log('***********Animal*****************');

			function Animal(){
				
			}
			Animal.f1 = function(){
				console.log('Animal.f1');
			}		

			Animal.prototype.f2 = function(){
				console.log('Animal.prototype.f2');
			}

			function Dog(){
			
			}

			var  anim = new Animal();
			Dog.prototype=anim;
			
			var d = new Dog();

	
	//函数对象.prototype是一个{},即普通对象；
	console.log('Animal.prototype:'+Animal.prototype);  //Animal.prototype:[object Object] 
	console.log('Animal.prototype===Object.prototype:'+(Animal.prototype===Object.prototype));   //false
	console.log('Animal.prototype===Function:'+(Animal.prototype===Function));    //false
	console.log('Animal.prototype===Function.prototype:'+(Animal.prototype===Function.prototype)); //false
	
	console.log('anim.__proto__===Animal.prototype:'+(anim.__proto__===Animal.prototype));  //true
	console.log('Animal.__proto__===Function.prototype:'+(Animal.__proto__===Function.prototype));  //true

	
	
	console.log('***********Function proto*****************');
	//Function.prototype是一个函数对象,这个函数对象很特殊，按理函数对象都会有一个prototype的属性，但是Function.prototype.prototype为undefied
	console.log('Function.prototype:'+Function.prototype);  //chrome: function Empty(){}      firefox:function()
	console.log('Function.prototype.prototype:'+Function.prototype.prototype); //undefined
	console.log('Function.prototype.__proto__:'+Function.prototype.__proto__);   //Object {}
	console.log('Function.__proto__:'+Function.__proto__);  //chrome: function Empty(){}      firefox:function()
	console.log('Function.__proto__===Function.prototype:'+(Function.__proto__===Function.prototype)); //true
	console.log('Function.prototype.__proto__===Object.prototype:'+(Function.prototype.__proto__===Object.prototype));   //true
	console.log('Function.__proto__.__proto__:'+Function.__proto__.__proto__);   //object {}

	console.log('***********Object proto*****************');
	console.log(typeof(Object.prototype) === 'object');  //true
	console.log('Object.prototype instanceof Object:'+Object.prototype instanceof Object);	//false
	//Object.prototype是一个普通对象
	console.log('Object.prototype:'+Object.prototype);  //Object {}    
	console.log('Object.prototype.prototype:'+Object.prototype.prototype);  //undefied
	console.log('Object.prototype.__proto__:'+Object.prototype.__proto__);  //null
	console.log('Object.prototype===Object.__proto__:'+(Object.prototype===Object.__proto__));  //false
	console.log('Object.__proto__:'+Object.__proto__);  //chrome: function Empty(){}      firefox:function() 



	console.log('Function.prototype.__proto__===Object.prototype:'+(Function.prototype.__proto__===Object.prototype));   //true
	console.log('Function.__proto__===Object.__proto__:'+(Function.__proto__===Object.__proto__));   //true
	console.log('Function.prototype===Object.__proto__:'+(Function.__proto__===Object.__proto__));   //true

	
	console.log('**************constructor****************'); 

	console.log('Function.constructor:'+Function.constructor);	//function Function() { [native code] }
	console.log('Function.prototype.constructor:'+Function.prototype.constructor);   //function Function() { [native code] }
	console.log('Function.__proto__.constructor:'+Function.__proto__.constructor);   //function Function() { [native code] } 
	console.log('Function.prototype.__proto__.constructor:'+Function.prototype.__proto__.constructor); //function Object() { [native code] }
	console.log('Object.constructor:'+Object.constructor);    //function Function() { [native code] }
	console.log('Object.prototype.constructor:'+Object.prototype.constructor);	//function Object() { [native code] } 
	console.log('Object.__proto__.constructor:'+Object.__proto__.constructor);   //function Function() { [native code] } basic.html:170
	//console.log('Object.prototype.__proto__.constructor:'+Object.prototype.__proto__.constructor); 
	//console.log('null.constructor:'+null.constructor); 
	console.log('NaN.constructor:'+NaN.constructor);   // function Number() { [native code] } 



	function Person(){
	
	}
  	console.log('******************************'); 
	console.log(Person.prototype);
	console.log(Person.prototype===Object.prototype); //false
	console.log(Person.prototype===Function);       //false
	console.log(Person.prototype===Function.prototype); //false
	  		

		
	</script>
</head>
<body>

</body>
	<div id='div1'>
		div1----
	</div>

</html>